/**
 * @file        RASAeroImport.cpp
 * @authors     Ayberk Yaraneri
 *
 * @brief      A utility class used to parse aerodynamic coefficients and
 * parameters generated by the RASAero software. The class stores the aero
 * parameters into a lookup table and makes them readily available through
 * getter functions. These getters interpolate the data as necessary.
 *
 */

#include "RASAeroImport.h"

#include <rapidcsv.h>

#include <cmath>
#include <iostream>
#include <set>
#include <string>

RASAeroImport::RASAeroImport(std::string file_path) {
    rapidcsv::Document csv(file_path);

    auto mach = csv.GetColumn<double>("Mach Number");
    auto alpha = csv.GetColumn<double>("Alpha (deg)");
    auto protuberance = csv.GetColumn<double>("Protuberance (%)");
    auto cd_poweroff = csv.GetColumn<double>("CD Power-Off");
    auto cd_poweron = csv.GetColumn<double>("CD Power-On");
    auto ca_poweroff = csv.GetColumn<double>("CA Power-Off");
    auto ca_poweron = csv.GetColumn<double>("CA Power-On");
    auto cn = csv.GetColumn<double>("CN Total");
    auto cp = csv.GetColumn<double>("CP Total");

    int n_data = mach.size();

    /*
    std::cout << "Number of Mach points = " << mach.size() << std::endl;
    std::cout << "Number of Alpha points = " << alpha.size() << std::endl;
    std::cout << "Number of protub points = " << protuberance.size() <<
    std::endl; std::cout << "Number of cd points = " << cd.size() << std::endl;
    */

    aero_table_.resize(n_data, 9);

    for (int i = 0; i < n_data; i++) {
        aero_table_(i, 0) = mach[i];
        aero_table_(i, 1) = alpha[i];
        aero_table_(i, 2) = protuberance[i];
        aero_table_(i, 3) = cd_poweroff[i];
        aero_table_(i, 4) = cd_poweron[i];
        aero_table_(i, 5) = ca_poweroff[i];
        aero_table_(i, 6) = ca_poweron[i];
        aero_table_(i, 7) = cn[i];
        aero_table_(i, 8) = cp[i];
    }

    // std::cout << aero_table_ << std::endl;

    set_mach_number_params();
    set_alpha_params();
    set_protuberance_params();

    std::cout << "mach_instances = " << mach_number_instances_ << std::endl;
    std::cout << "mach_fidelity = " << mach_number_fidelity_ << std::endl;
    std::cout << "alpha_instances = " << alpha_instances_ << std::endl;
    std::cout << "alpha_fidelity = " << alpha_fidelity_ << std::endl;
    std::cout << "protuberance_instances = " << protuberance_instances_ << std::endl;
    std::cout << "protuberance_fidelity = " << protuberance_fidelity_ << std::endl;
}

void RASAeroImport::set_mach_number_params() {
    auto column = aero_table_.col(0);
    auto vec = std::vector<double>(column.begin(), column.end());
    sort(vec.begin(), vec.end());
    vec.erase(unique(vec.begin(), vec.end()), vec.end());
    mach_number_instances_ = vec.size();
    mach_number_fidelity_ = fabs(vec[0] - vec[1]);
}

void RASAeroImport::set_alpha_params() {
    auto column = aero_table_.col(1);
    auto vec = std::vector<double>(column.begin(), column.end());
    sort(vec.begin(), vec.end());
    vec.erase(unique(vec.begin(), vec.end()), vec.end());
    alpha_instances_ = vec.size();
    alpha_fidelity_ = fabs(vec[0] - vec[1]);
}

void RASAeroImport::set_protuberance_params() {
    auto column = aero_table_.col(2);
    auto vec = std::vector<double>(column.begin(), column.end());
    sort(vec.begin(), vec.end());
    vec.erase(unique(vec.begin(), vec.end()), vec.end());
    protuberance_instances_ = vec.size();
    protuberance_fidelity_ = fabs(vec[0] - vec[1]);
}

RASAeroCoefficients RASAeroImport::get_aero_coefficients(
    double mach, double alpha, double protuberance_percent) {

    // Find closest mach number to passed mach value
    double mach_below =
        std::trunc(mach / mach_number_fidelity_) * mach_number_fidelity_;
    double closest_mach = mach_below;
    if ((mach - mach_below) >= (mach_number_fidelity_ / 2.0))
        closest_mach = mach_below + mach_number_fidelity_;

    // Find alpha values to interpolate among
    double alpha_below = std::trunc(alpha / alpha_fidelity_) * alpha_fidelity_;
    double alpha_above = alpha_below + alpha_fidelity_;

    // Find protub values to interpolate among
    double prot_below =
        std::trunc(protuberance_percent / protuberance_fidelity_) *
        protuberance_fidelity_;
    double prot_above = prot_below + protuberance_fidelity_;

    int mach_start_index = ((closest_mach / mach_number_fidelity_) - 1) *
                           (alpha_instances_ * protuberance_instances_);
    int row_a_offset_index =
        (alpha_below / alpha_fidelity_) * (protuberance_instances_);

    std::cout << "get_aero_coefficients:" << std::endl;
    std::cout << "mach_below = " << mach_below << std::endl;
    std::cout << "closest_mach = " << closest_mach << std::endl;
    std::cout << "alpha_below = " << alpha_below << std::endl;
    std::cout << "alpha_above = " << alpha_above << std::endl;
    std::cout << "prot_below = " << prot_below << std::endl;
    std::cout << "prot_above = " << prot_above << std::endl;

    return {};
}









